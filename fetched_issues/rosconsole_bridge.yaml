- url: 'https://github.com/ros/rosconsole_bridge/pull/16'
  title: Fix static destruction ordering issue on macOS
  body: "This is a follow-up of #10 (fix: on destruction OutputHandlerROS should restore the previous handler).\r\n\r\n### Problem Description\r\nWhile for Linux the proposed fix works nicely and avoids the pure virtual method call demonstrated by the `cleanup` unit test, on macOS the added call to `console_bridge::restorePreviousOutputHandler()` in the destructor of `OutputHandlerROS` triggers an exception because [this mutex](https://github.com/ros/console_bridge/blob/master/src/console.cpp#L60) in `console_bridge`'s [`static DefaultHandler DOH`](https://github.com/ros/console_bridge/blob/master/src/console.cpp#L69) struct has already been destructed when the call to `console_bridge::restorePreviousOutputHandler()` tries to lock it during the static destruction of [RegisterOutputHandlerProxy](https://github.com/rhaschke/rosconsole_bridge/blob/04d37b29f181696588f1780507e1a73fcab21cb5/src/bridge.cpp#L48]).\r\n\r\n```\r\nlibc++abi.dylib: terminating with uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument\r\nProcess 13839 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGABRT\r\n    frame #0: 0x00007fffb664fd42 libsystem_kernel.dylib`__pthread_kill + 10\r\nlibsystem_kernel.dylib`__pthread_kill:\r\n->  0x7fffb664fd42 <+10>: jae    0x7fffb664fd4c            ; <+20>\r\n    0x7fffb664fd44 <+12>: movq   %rax, %rdi\r\n    0x7fffb664fd47 <+15>: jmp    0x7fffb6648caf            ; cerror_nocancel\r\n    0x7fffb664fd4c <+20>: retq\r\nTarget 0: (rviz) stopped.\r\n(lldb) bt\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGABRT\r\n  * frame #0: 0x00007fffb664fd42 libsystem_kernel.dylib`__pthread_kill + 10\r\n    frame #1: 0x00007fffb673d457 libsystem_pthread.dylib`pthread_kill + 90\r\n    frame #2: 0x00007fffb65b5420 libsystem_c.dylib`abort + 129\r\n    frame #3: 0x00007fffb510994a libc++abi.dylib`abort_message + 266\r\n    frame #4: 0x00007fffb512ec17 libc++abi.dylib`default_terminate_handler() + 243\r\n    frame #5: 0x00007fffb5c3d713 libobjc.A.dylib`_objc_terminate() + 124\r\n    frame #6: 0x00007fffb512bd49 libc++abi.dylib`std::__terminate(void (*)()) + 8\r\n    frame #7: 0x00007fffb512bdc3 libc++abi.dylib`std::terminate() + 51\r\n    frame #8: 0x000000010229a11b librosconsole_bridge.dylib`__clang_call_terminate + 11\r\n    frame #9: 0x000000010229a13d librosconsole_bridge.dylib`rosconsole_bridge::OutputHandlerROS::~OutputHandlerROS() + 29\r\n    frame #10: 0x00007fffb65b6178 libsystem_c.dylib`__cxa_finalize_ranges + 332\r\n    frame #11: 0x00007fffb65b64b2 libsystem_c.dylib`exit + 55\r\n    frame #12: 0x00007fffb652123c libdyld.dylib`start + 8\r\n(lldb)\r\n```\r\n(after quitting rviz with ROS kinetic built from source on macOS Sierra 10.12, with system dependencies installed from HomeBrew, with console_bridge 0.4.0 and rosconsole_bridge version 0.5.1)\r\n\r\nI could not reproduce this problem for \"normal\" executables that only link statically to dynamic libraries, but the exception is triggered consistently if the application loaded libraries dynamically at run-time (`dlopen()`, e.g. through pluginlib) that directly or indirectly link to `librosconsole_bridge.dylib`.\r\n\r\nThe root cause is likely the different ordering of Linux and Darwin during the static initialization and destruction phase. While Linux initializes all global symbols right after a dynamic library has been loaded, Darwin only initializes them on first use. Apparently that is what is called \"[deferred dynamic initialization](https://en.cppreference.com/w/cpp/language/initialization#Deferred_dynamic_initialization)\" in [1], which is allowed by the C++ standard [2]. The destruction happens in strictly reverse order of initialization in both cases, where the completion of the constructor or dynamic initialization is the synchronization point [3].\r\n\r\nIf the construction of [OutputHandlerROS](https://github.com/rhaschke/rosconsole_bridge/blob/04d37b29f181696588f1780507e1a73fcab21cb5/src/bridge.cpp#L48]) called during static initialization of [oh_ros](https://github.com/rhaschke/rosconsole_bridge/blob/04d37b29f181696588f1780507e1a73fcab21cb5/src/bridge.cpp#L126) from the [constructor of RegisterOutputHandlerProxy]([https://github.com/rhaschke/rosconsole_bridge/blob/04d37b29f181696588f1780507e1a73fcab21cb5/src/bridge.cpp#L124) finishes before the first call to [getDOH()](https://github.com/ros/console_bridge/blob/master/src/console.cpp#L67), which in turn initializes the mutex as part of the static initialization of [DefaultOutputHandler DOH](https://github.com/ros/console_bridge/blob/master/src/console.cpp#L69), the mutex also gets destroyed before the [destruction of oh_ros](https://github.com/rhaschke/rosconsole_bridge/blob/04d37b29f181696588f1780507e1a73fcab21cb5/src/bridge.cpp#L48), which calls into [console_bridge::restorePreviousOutputHandler](https://github.com/ros/console_bridge/blob/master/src/console.cpp#L88) and tries to lock it.\r\n\r\n### Proposed patch\r\nThe solution is to make sure that the output handler is restored during the destruction of exactly the same object that installed a new one, namely `RegisterOutputHandlerProxy`. If it's not the constructor of `OutputHandlerROS` that calls `console_bridge::useOutputHandler(this)`, it should also not be the destructors responsibility to call `console_bridge::restorePreviousOutputHandler()`.\r\n\r\nNote that there might be more than one instance of `RegisterOutputHandlerProxy` in a single process because it can be instantiated once for every compilation unit that included the [REGISTER_ROSCONSOLE_BRIDGE](https://github.com/rhaschke/rosconsole_bridge/blob/04d37b29f181696588f1780507e1a73fcab21cb5/include/rosconsole_bridge/bridge.h#L60) macro that defines the symbol `rosconsole_bridge::RegisterOutputHandlerProxy __register_rosconsole_output_handler_proxy`, depending on whether it is loaded with [RTLD_GLOBAL](http://pubs.opengroup.org/onlinepubs/7908799/xsh/dlopen.html) or not, and they refer to either the same or a different instance of [static OutputHandlerROS oh_ros](https://github.com/rhaschke/rosconsole_bridge/blob/04d37b29f181696588f1780507e1a73fcab21cb5/src/bridge.cpp#L126).\r\n\r\n### ABI compatibility (tested on Xenial only)\r\nI think the same reasoning about ABI-compatibility as in https://github.com/ros/rosconsole_bridge/pull/10#discussion_r59419426 applies to this patch, too:\r\n```\r\n$ abi-compliance-checker -l rosconsole_bridge -old rosconsole_bridge-0.5.1.dump -new rosconsole_bridge-fix.dump \r\npreparation, please wait ...\r\nWARNING: version number #1 is not set (use --v1=NUM option)\r\nWARNING: version number #2 is not set (use --v2=NUM option)\r\ncomparing ABIs ...\r\ncomparing APIs ...\r\ncreating compatibility report ...\r\nresult: COMPATIBLE\r\ntotal \"Binary\" compatibility problems: 0, warnings: 0\r\ntotal \"Source\" compatibility problems: 0, warnings: 0\r\nsee detailed report:\r\n  compat_reports/rosconsole_bridge/X_to_Y/compat_report.html\r\n```\r\n\r\nBut as the definition of `RegisterOutputHandlerProxy` has been changed, which is actually instantiated in another compilation unit (e.g. `liburdf.so`), we also have to test this one:\r\n```\r\n$ abi-compliance-checker -l urdf -old urdf-0.5.1.dump -new urdf-fix.dump \r\npreparation, please wait ...\r\nWARNING: version number #1 is not set (use --v1=NUM option)\r\nWARNING: version number #2 is not set (use --v2=NUM option)\r\ncomparing ABIs ...\r\ncomparing APIs ...\r\ncreating compatibility report ...\r\nresult: COMPATIBLE\r\ntotal \"Binary\" compatibility problems: 0, warnings: 0\r\ntotal \"Source\" compatibility problems: 0, warnings: 0\r\nsee detailed report:\r\n  compat_reports/urdf/X_to_Y/compat_report.html\r\n```\r\n\r\nThat being said, even if ABI compatible, if only rosconsole_bridge would be recompiled/upgraded, but not the compilation unit that expands the [REGISTER_ROSCONSOLE_BRIDGE](https://github.com/rhaschke/rosconsole_bridge/blob/04d37b29f181696588f1780507e1a73fcab21cb5/include/rosconsole_bridge/bridge.h#L60) macro and instantiates `RegisterOutputHandlerProxy`, none of the two destructors would be called which might result in the pure virtual method call during static destruction again.\r\n\r\n### Unit test\r\nThe [add_test()](https://cmake.org/cmake/help/v3.0/command/add_test.html) call in [test/CMakeLists.txt:4](https://github.com/meyerj/rosconsole_bridge/blob/ef57ce056c886566720d524e9db0104d743d9ab1/test/CMakeLists.txt#L4) was missing a `NAME` keyword, which is why it always failed for me when running through the target `test` generated by cmake, because it tried to execute a command called `COMMAND`. Also note that the unit test is not using [catkin's test infrastructure](http://docs.ros.org/api/catkin/html/howto/format2/run_tests.html) which defines the targets `tests` and `run_tests` and only provides macros for nosetests and gtest. It will not run automatically on `make run_tests` or [on the ROS build farm](http://build.ros.org/job/Kdev__rosconsole_bridge__ubuntu_xenial_amd64/8/console). In order to fix that catkin should provide a macro like `catkin_add_test()` that is not specific to a certain testing library and can execute arbitrary commands, but which integrates with its `run_tests` target.\r\n\r\n### References\r\n[1] https://en.cppreference.com/w/cpp/language/initialization#Deferred_dynamic_initialization\r\n[2] http://eel.is/c++draft/basic.start.dynamic#4\r\n[3] http://eel.is/c++draft/basic.start#term-3\r\n\r\n"
  repo: 'https://api.github.com/repos/ros/rosconsole_bridge'
  labels:
    - bug
- url: 'https://github.com/ros/rosconsole_bridge/pull/13'
  title: Feature/support multiple activation and deactivation
  body: "This supports linking multiple `REGISTER_ROSCONSOLE_BRIDGE;` together and therefore enables ROS libraries to take care of this for non-ROS libraries they might depend on without risk.\r\n\r\nThis is one possible first step to improve on issue #12 .\r\n\r\nThe extra complexity to support deactivation is not necessary.\r\nCurrently it is just used to allow the \"cleanup\" test to remain partial functional. Admittedly this way it does not serve as much of a purpose as before. The problem is the introduced singleton that takes care of disabling the output handler at program termination. I don't know an easy way to test this from within the program without extra complexity in the library itself. However, the standard guarantees the destruction of static locals within the program termination phase - as far as I know. And the deactivate functionality is still successfully tested:\r\n\r\n> [ WARN] [1501317381.498355918]: This warning should be served through rosconsole\r\n> Warning: This warning should be served through the original console_bridge output handler\r\n         at line 9 in .../rosconsole_bridge/test/cleanup.cpp\r\n\r\n(its output on my system)\r\n"
  repo: 'https://api.github.com/repos/ros/rosconsole_bridge'
  labels: []
- url: 'https://github.com/ros/rosconsole_bridge/issues/12'
  title: How to really use rosconsole_bridge?
  body: "The requirement to use `REGISTER_ROSCONSOLE_BRIDGE` (e.g. https://github.com/ros/rosconsole_bridge/blob/indigo-devel/test/cleanup.cpp#L16) is not mentioned in http://wiki.ros.org/rosconsole_bridge, which states instead :\r\n\r\n> If you have a console_bridge application or library, you can have its output be written to /rosout by simply having your package depend on rosconsole_bridge. \r\n\r\nHowever it doesn't work without `REGISTER_ROSCONSOLE_BRIDGE;` somewhere to actually cause the redirection.\r\n\r\nAssuming that this is intended, a) it should be mentioned in the documentation, and b) there seems to be a design flaw not providing a clean solution for the following situation (among others): \r\n\r\nLib `A` depends on ROS and lib `B`, which uses console_bridge. Then lib `A` should ideally already activate `rosconsole_bridge` for lib `B` to nicely work as ROS-lib and therefore have somewhere `REGISTER_ROSCONSOLE_BRIDGE;`. However, in an executable that depends on A and an A' doing the same thing would end up redirecting the console twice through A and A'. This works but yields unclean shutdown because it is apparently not supported in https://github.com/ros/console_bridge/blob/master/src/console.cpp#L94 since there is only one `previous_output_handler_`.\r\n\r\nAll problems could (IMO) be solved simply by using `REGISTER_ROSCONSOLE_BRIDGE` within the `rosconsole_bridge` library itself and not in its clients. This should make sure that the redirection is only happening once per executable AND get rid of this requirement for client packages and make the simplicity promised in the wiki come true. \r\nWhat is wrong with this approach?\r\n"
  repo: 'https://api.github.com/repos/ros/rosconsole_bridge'
  labels: []
- url: 'https://github.com/ros/rosconsole_bridge/pull/3'
  title: fixing catkin as a buildtool dependency
  body: |
    The catkin dependency should be a buildtool not a build depend.
  repo: 'https://api.github.com/repos/ros/rosconsole_bridge'
  labels: []
- url: 'https://github.com/ros/rosconsole_bridge/pull/1'
  title: Update cmake to pass along console_bridge
  body: |
    It was not passing along rosconsole or console_bridge correctly.

    It was find_package'ing after catkin_package.

    It was not treating console_bridge like a catkin dependency.
  repo: 'https://api.github.com/repos/ros/rosconsole_bridge'
  labels: []
