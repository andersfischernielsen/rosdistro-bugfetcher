- url: 'https://github.com/ROBOTIS-GIT/DynamixelSDK/issues/286'
  title: 'Reading AX-12A Status Packet (Python, Raspbian, Raspberry Pi 3B)'
  body: "Hello, I purchased 4 AX-12A actuators and I'm trying to capture a status packet using Raspberry Pi 3B. I'm able to successfully communicate with the AX-12A. I can move to goal positions successfully and control many parameters from the control table. The code below works really well for sending instruction packets. I just need sample Python code for reading the status packets. I'm using an octal tri-state buffer on a breadboard (74LS241) for half-duplex communication.\r\n\r\n============== source code ======================\r\nimport serial\r\nimport time\r\nimport RPi.GPIO as GPIO\r\n\r\nchannel = 18\r\n\r\nGPIO.setmode(GPIO.BCM)\r\nGPIO.setup(channel, GPIO.OUT)\r\n\r\nser = serial.Serial(\"/dev/ttyS0\", baudrate=1000000, timeout=3.0)\r\n\r\nGPIO.output(channel, GPIO.HIGH)\r\nser.write(bytearray.fromhex(\"FF FF 01 05 03 1E 32 03 A3\"))\r\ntime.sleep(0.1)\r\nGPIO.output(channel, GPIO.LOW)\r\ntime.sleep(3)\r\n\r\nGPIO.output(channel, GPIO.HIGH)\r\nser.write(bytearray.fromhex(\"FF FF 01 05 03 1E CD 00 0b\"))\r\ntime.sleep(0.1)\r\nGPIO.output(channel, GPIO.LOW)\r\ntime.sleep(3)\r\n    \r\nser.close()\r\nGPIO.cleanup()\r\n"
  repo: 'https://api.github.com/repos/ROBOTIS-GIT/DynamixelSDK'
  labels:
    - question
    - waiting for reply
- url: 'https://github.com/ROBOTIS-GIT/DynamixelSDK/issues/280'
  title: '[C++] [Arduino] [OpenCM904] Adding a "Freeze" feature to the SDK/servos'
  body: "Hello,\r\n\r\nI'm posting a request for an addition of an important missing feature. Currently there is no way to tell a servo to stop moving and hold it's current position. Our team needs this feature to use on robotic arms. We need to be able to stop an arm or the arm gripper when sensors detect it is time to stop. \r\n\r\nFor example, having an FSR in the gripper finger and sending a goal position to close the gripper, but once it grasps the object and the FSR indicates firm contact we then send the \"freeze\" command to the servo to stop it from closing further.\r\n\r\nAnother example would be using IR senors to detect position. Either to find an object to pick up, or collision detection for example. When the sensor signals to stop we could then tell all servos to freeze.\r\n\r\nAnother example would be a safety button. When pushed it freezes the arm in place.\r\n\r\nTorquing off the servos isn't a solution of course because the whole are goes limp and comes crashing down. We have tried doing a very fast position read and sending a new goal position, but this doesn't work. The servo will continue moving for some time then reverse direction back to the new goal position. We need to be able to do an immediate freeze in place for an immediate stop and hold.\r\n\r\nThank you very much!\r\n\r\nMatt"
  repo: 'https://api.github.com/repos/ROBOTIS-GIT/DynamixelSDK'
  labels:
    - question
- url: 'https://github.com/ROBOTIS-GIT/DynamixelSDK/issues/270'
  title: not interfacing the motors after changing the baud rate
  body: "Hi, I am using the motor XM430-w350-R, The python programe of DynamixelSDK is used (protocol 2, see part of codes as follows). \r\n\r\nI changed the rate (i.e., 57600) to 4000000, then the motor could not be connected (e.g., ping), I changed BAUDRATE from 9,600 to 4.5M, but none of them succeed to ping. Is there any way to mechanically reboot the motor, such that it goes to the factory setup?\r\n\r\nthe print result:\r\n\r\npython ping.py \r\nSucceeded to open the port\r\nSucceeded to change the baudrate\r\n\r\n\r\n\r\n\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\r\n################################################################################\r\n# Copyright 2017 ROBOTIS CO., LTD.\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the \"License\");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n#\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n#\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n################################################################################\r\n\r\n# Author: Ryu Woon Jung (Leon)\r\n\r\n#\r\n# *********     ping Example      *********\r\n#\r\n#\r\n# Available Dynamixel model on this example : All models using Protocol 2.0\r\n# This example is designed for using a Dynamixel PRO 54-200, and an USB2DYNAMIXEL.\r\n# To use another Dynamixel model, such as X series, see their details in E-Manual(emanual.robotis.com) and edit below variables yourself.\r\n# Be sure that Dynamixel PRO properties are already set as %% ID : 1 / Baudnum : 1 (Baudrate : 57600)\r\n#\r\n\r\nimport os\r\n\r\nif os.name == 'nt':\r\n    import msvcrt\r\n    def getch():\r\n        return msvcrt.getch().decode()\r\nelse:\r\n    import sys, tty, termios\r\n    fd = sys.stdin.fileno()\r\n    old_settings = termios.tcgetattr(fd)\r\n    def getch():\r\n        try:\r\n            tty.setraw(sys.stdin.fileno())\r\n            ch = sys.stdin.read(1)\r\n        finally:\r\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\r\n        return ch\r\n\r\nfrom dynamixel_sdk import *                 # Uses Dynamixel SDK library\r\n\r\n# Protocol version\r\nPROTOCOL_VERSION        = 2.0               # See which protocol version is used in the Dynamixel\r\n\r\n# Default setting\r\nDXL_ID                  = 2#1                 # Dynamixel ID : 1\r\nBAUDRATE                = 9600#57600#4000000#             # Dynamixel default baudrate : 57600\r\nDEVICENAME              = '/dev/ttyUSB0'    # Check which port is being used on your controller\r\n                                            # ex) Windows: \"COM1\"   Linux: \"/dev/ttyUSB0\" Mac: \"/dev/tty.usbserial-*\"\r\n\r\n# Initialize PortHandler instance\r\n# Set the port path\r\n# Get methods and members of PortHandlerLinux or PortHandlerWindows\r\nportHandler = PortHandler(DEVICENAME)\r\n\r\n# Initialize PacketHandler instance\r\n# Set the protocol version\r\n# Get methods and members of Protocol1PacketHandler or Protocol2PacketHandler\r\npacketHandler = PacketHandler(PROTOCOL_VERSION)\r\n\r\n# Open port\r\nif portHandler.openPort():\r\n    print(\"Succeeded to open the port\")\r\nelse:\r\n    print(\"Failed to open the port\")\r\n    print(\"Press any key to terminate...\")\r\n    getch()\r\n    quit()\r\n\r\n\r\n# Set port baudrate\r\nif portHandler.setBaudRate(BAUDRATE):\r\n    print(\"Succeeded to change the baudrate\")\r\nelse:\r\n    print(\"Failed to change the baudrate\")\r\n    print(\"Press any key to terminate...\")\r\n    getch()\r\n    quit()\r\n\r\n# Try to ping the Dynamixel\r\n# Get Dynamixel model number\r\n\r\nfor i in range(1000):\r\n    dxl_model_number, dxl_comm_result, dxl_error = packetHandler.ping(portHandler, i)#DXL_ID)\r\n    if dxl_comm_result != COMM_SUCCESS:\r\n        n=0\r\n        #print(\"%s\" % packetHandler.getTxRxResult(dxl_comm_result))\r\n    elif dxl_error != 0:\r\n        #print(\"%s\" % packetHandler.getRxPacketError(dxl_error))\r\n        n=0\r\n    else:\r\n        print(\"[ID:%03d] ping Succeeded. Dynamixel model number : %d\" % (i,dxl_model_number))#DXL_ID, dxl_model_number))\r\n\r\n# Close port\r\nportHandler.closePort()\r\n"
  repo: 'https://api.github.com/repos/ROBOTIS-GIT/DynamixelSDK'
  labels:
    - question
- url: 'https://github.com/ROBOTIS-GIT/DynamixelSDK/issues/263'
  title: 'C++ Library design issue '
  body: >-
    Hi. I'm getting troubles compiling the library in different Ide's. For
    example, if I compile the dll on Visual Studio I cannot use it in QtCreator
    project. Even more, If I compile the dll on QtCreator and I use it on Qt
    project it doesn't work correctly ( on MSVC2017 64bit or MinGW32bit is the
    same). The only way that works correctly is if the library and the project
    are compiled with the same compiler (using Visual Studio) in the same
    machine; other combination may not work. I think the problem relies on the
    header of the library ( dynamixel_sdk.h and its dependencies). It's
    manifested on warning C4251 which is getting in any project compilation
    using this library. The solution is to use d-pointers; I suggest this link
    to understand the problem: https://wiki.qt.io/D-Pointer
  repo: 'https://api.github.com/repos/ROBOTIS-GIT/DynamixelSDK'
  labels:
    - enhancement
    - in progress
- url: 'https://github.com/ROBOTIS-GIT/DynamixelSDK/issues/233'
  title: DynamixelSDK feature request for readTxRx and writeTxRx
  body: "Hello,\r\n\r\nI was asked to submit this feature request here.\r\n\r\nWe are currently writing our firmware for the CM9.04 controller to run our robotic arms and we use protocol 2. In order to read and write data we have to send the register byte length over in the serial packets in order to do an 'if then' statement to decide which function to use.\r\n\r\n\r\n\r\n`\r\n\r\n            if intByteCount == 1) {\r\n              int8_t intreturnedvalue;\r\n              dxl_comm_result = packetHandler->read1ByteTxRx(portHandler, PacketReceivedInstDetail_1, PacketReceivedRegAddressValue, (uint8_t*)&intreturnedvalue, &dxl_error);\r\n\r\n            } else if intByteCount == 2) {\r\n              \r\n              int16_t intreturnedvalue;\r\n              dxl_comm_result = packetHandler->read2ByteTxRx(portHandler, PacketReceivedInstDetail_1, PacketReceivedRegAddressValue, (uint16_t*)&intreturnedvalue, &dxl_error);\r\n              \r\n            } else if intByteCount == 4) {\r\n              \r\n              int32_t intreturnedvalue;\r\n              dxl_comm_result = packetHandler->read4ByteTxRx(portHandler, PacketReceivedInstDetail_1, PacketReceivedRegAddressValue, (uint32_t*)&intreturnedvalue, &dxl_error);\r\n              \r\n            }\r\n`\r\n\r\n\r\nWhile having this in our firmware is not a big deal. All the work on front end software to track and send over register byte counts is very troublesome. For our software we have to store CSV files for every family of servos and do data imports, and lookups, and passing over of the byte length. It was a lot of added plumbing code to manage to make read/write to registers work. \r\n\r\nWhen our firmware is done and released we will be releasing the serial protocol for communicating with it. Since we have no choice but to have to know the register byte length that means that we have to ask our clients and customers to also have to pass it to our firmware. \r\n\r\nIt seems redundant to have to tell the function what the byte length is. The DynamixelSDK should know the byte length internally for it's own register tables. Our request is that a version of readTxRx and writeTxRx be added that does not request the packet length. I imagine then the returned value can always be an int 32 to handle all integer sizes up to 4 bytes. This would help simplify code for your users and third party partners.\r\n\r\nreadTxRx\r\nhttp://emanual.robotis.com/docs/en/software/dynamixel/dynamixel_sdk/api_reference/cpp/cpp_packethandler/#cpp-protocol2packethandler\r\n\r\nwriteTxRx\r\nhttp://emanual.robotis.com/docs/en/software/dynamixel/dynamixel_sdk/api_reference/cpp/cpp_packethandler/#cpp-protocol2packethandler\r\n\r\n\r\nThank You!\r\n\r\nMatt\r\n\r\n\r\n"
  repo: 'https://api.github.com/repos/ROBOTIS-GIT/DynamixelSDK'
  labels:
    - question
- url: 'https://github.com/ROBOTIS-GIT/DynamixelSDK/issues/231'
  title: >-
    [3.6.2][Java][USB2Dynamixel2][XH430-W350-R] DynamixelSDK documentation
    enhancement request
  body: "I'm trying to put together a Java wrapper to abstract the direct byte[] communication over serial into functions servo objects with functions like `setGoalPosition(int newPosition)`, `setLED(boolean isOn);`, `setTorque(boolean isOn);`, etc.\r\n\r\nWhile this worked nicely with a single U2D2 device I ran into some abstraction errors using multiple servo instances.\r\n\r\nI've read the available documentation clearly, but it's only after I've carefully read the c PortHandler and PacketHandler code I understood why I was getting errors or unexpected behaviours:\r\n\r\n1. `dynamixel.portHandler(DEVICENAME1);` **must be called** once per device **before** calling `dynamixel.openPort(port_num);`\r\n2. `dynamixel.packetHandler();` **must** be called after the ports are opened and baud rate is set\r\n\r\nTo detail **item 1**:\r\n\r\nThe expected behaviours to be able to call `portHandler()`, then `openPort` and `setBaudRate` for a device and repeat the procedure for a second device in this order. However, if I do that `portHandler()` returns the port index as `0` for both devices. \r\nIt's only if I call `portHandler()` in two consecutive calls (without any other dynamixel calls in between) that the second port returns index `1` as expected.\r\n\r\nThe [Java Multi Port Protocol 2.0 Sample Code](http://emanual.robotis.com/docs/en/software/dynamixel/dynamixel_sdk/sample_code/java_multi_port_protocol_2_0/#java-multi-port-protocol-20) does indeed use the right order, however it was unclear at first glance that it's required to call `portHandler()` in one section for all ports to get the expected outcome.\r\n\r\nPerhaps this section >This initializes Dynamixel class.\r\n```java\r\n// Initialize PortHandler Structs\r\n// Set the port path\r\n// Get methods and members of PortHandlerLinux or PortHandlerWindows\r\nint port_num1 = dynamixel.portHandler(DEVICENAME1);\r\nint port_num2 = dynamixel.portHandler(DEVICENAME2);\r\n```\r\n`portHandler()` function sets port path as `DEVICENAME1` and `DEVICENAME2` and get `port_num1` and `port_num2` each, and prepares an appropriate functions for port control in controller OS automatically. `port_num1` and `port_num2` would be used in many functions in the body of the code to specify the port for use.\r\n\r\ncan explain how important it is do this calls as in the example and not as I attempted (`portHandler()` then `openPort()` then `setBaudRate()` then `portHandler() again for a second device).\r\n\r\nFor reference his a modified test version MultiPort.java I've used: an example of how *not* to open multiple ports:\r\n\r\n```java\r\n\r\n\r\n/*******************************************************************************\r\n* Copyright 2017 ROBOTIS CO., LTD.\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*     http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*******************************************************************************/\r\n\r\n/* Author: Ryu Woon Jung (Leon) */\r\n\r\n//\r\n// *********     MultiPort Example      *********\r\n//\r\n//\r\n// Available Dynamixel model on this example : All models using Protocol 2.0\r\n// This example is designed for using two Dynamixel PRO 54-200, and two USB2DYNAMIXELs.\r\n// To use another Dynamixel model, such as X series, see their details in E-Manual(emanual.robotis.com) and edit below variables yourself.\r\n// Be sure that Dynamixel PRO properties are already set as %% ID : 1 / Baudnum : 1 (Baudrate : 57600)\r\n//\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class MultiPort\r\n{\r\n  public static void main(String[] args)\r\n  {\r\n    // Control table address\r\n\t short ADDR_PRO_TORQUE_ENABLE        = 64;                // Control table address is different in Dynamixel model\r\n    short ADDR_PRO_GOAL_POSITION        = 116;\r\n    short ADDR_PRO_PRESENT_POSITION     = 132;\r\n\r\n    // Protocol version\r\n    int PROTOCOL_VERSION                = 2;                   // See which protocol version is used in the Dynamixel\r\n\r\n    // Default setting\r\n    byte DXL1_ID                        = 5;                   // Dynamixel ID: 1\r\n    byte DXL2_ID                        = 6;                   // Dynamixel ID: 2\r\n    int BAUDRATE                        = 57600;\r\n    String DEVICENAME1                   = \"/dev/tty.usbserial-FT2GZFK0\";     // Check which port is being used on your controller\r\n    String DEVICENAME2                   = \"/dev/tty.usbserial-FT2H2YBE\";     // ex) Windows: \"COM1\"   Linux: \"/dev/ttyUSB0\" Mac: \"/dev/tty.usbserial-*\"\r\n\r\n    byte TORQUE_ENABLE                  = 1;                   // Value for enabling the torque\r\n    byte TORQUE_DISABLE                 = 0;                   // Value for disabling the torque\r\n    int DXL_MINIMUM_POSITION_VALUE      = 2000;             // Dynamixel will rotate between this value\r\n    int DXL_MAXIMUM_POSITION_VALUE      = 2096;              // and this value (note that the Dynamixel would not move when the position value is out of movable range. Check e-manual about the range of the Dynamixel you use.)\r\n    int DXL_MOVING_STATUS_THRESHOLD     = 20;                  // Dynamixel moving status threshold\r\n\r\n    String KEY_FOR_ESCAPE               = \"e\";                 // Key for escape\r\n\r\n    int COMM_SUCCESS                    = 0;                   // Communication Success result value\r\n    int COMM_TX_FAIL                    = -1001;               // Communication Tx Failed\r\n\r\n    // Instead of getch\r\n    Scanner scanner = new Scanner(System.in);\r\n\r\n    // Initialize Dynamixel class for java\r\n    Dynamixel dynamixel = new Dynamixel();\r\n\r\n    // Initialize PortHandler Structs\r\n    // Set the port path\r\n    // Get methods and members of PortHandlerLinux or PortHandlerWindows\r\n    int port_num1 = dynamixel.portHandler(DEVICENAME1);\r\n    \r\n\r\n    \r\n    int index = 0;\r\n    int dxl_comm_result = COMM_TX_FAIL;                        // Communication result\r\n    int[] dxl_goal_position = new int[]{DXL_MINIMUM_POSITION_VALUE, DXL_MAXIMUM_POSITION_VALUE};         // Goal position\r\n\r\n    byte dxl_error = 0;                                        // Dynamixel error\r\n    int dxl1_present_position = 0, dxl2_present_position = 0;  // Present position\r\n\r\n    // Open port1\r\n    if (dynamixel.openPort(port_num1))\r\n    {\r\n      System.out.println(\"Succeeded to open the port(\"+port_num1+\")!\");\r\n    }\r\n    else\r\n    {\r\n      System.out.println(\"Failed to open the port!\");\r\n      System.out.println(\"Press any key to terminate...\");\r\n      scanner.nextLine();\r\n      return;\r\n    }\r\n    \r\n // Set port1 baudrate\r\n    if (dynamixel.setBaudRate(port_num1, BAUDRATE))\r\n    {\r\n      System.out.println(\"Succeeded to change the baudrate!\");\r\n    }\r\n    else\r\n    {\r\n      System.out.println(\"Failed to change the baudrate!\");\r\n      System.out.println(\"Press any key to terminate...\");\r\n      scanner.nextLine();\r\n      return;\r\n    }\r\n    \r\n    int port_num2 = dynamixel.portHandler(DEVICENAME2);\r\n    // Open port2\r\n    if (dynamixel.openPort(port_num2))\r\n    {\r\n      System.out.println(\"Succeeded to open the port(\"+port_num2+\")!\");\r\n    }\r\n    else\r\n    {\r\n      System.out.println(\"Failed to open the port!\");\r\n      System.out.println(\"Press any key to terminate...\");\r\n      scanner.nextLine();\r\n      return;\r\n    }\r\n    \r\n    // Set port2 baudrate\r\n    if (dynamixel.setBaudRate(port_num1, BAUDRATE))\r\n    {\r\n      System.out.println(\"Succeeded to change the baudrate!\");\r\n    }\r\n    else\r\n    {\r\n      System.out.println(\"Failed to change the baudrate!\");\r\n      System.out.println(\"Press any key to terminate...\");\r\n      scanner.nextLine();\r\n      return;\r\n    }\r\n    \r\n    // Initialize PacketHandler Structs\r\n    dynamixel.packetHandler();\r\n\r\n    // Enable Dynamixel#1 Torque\r\n    dynamixel.write1ByteTxRx(port_num1, PROTOCOL_VERSION, DXL1_ID, ADDR_PRO_TORQUE_ENABLE, TORQUE_ENABLE);\r\n    if ((dxl_comm_result = dynamixel.getLastTxRxResult(port_num1, PROTOCOL_VERSION)) != COMM_SUCCESS)\r\n    {\r\n      System.out.println(dynamixel.getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));\r\n    }\r\n    else if ((dxl_error = dynamixel.getLastRxPacketError(port_num1, PROTOCOL_VERSION)) != 0)\r\n    {\r\n      System.out.println(dynamixel.getRxPacketError(PROTOCOL_VERSION, dxl_error));\r\n    }\r\n    else\r\n    {\r\n      System.out.printf(\"Dynamixel#%d has been successfully connected\\n\", DXL1_ID);\r\n    }\r\n\r\n    // Enable Dynamixel#2 Torque\r\n    dynamixel.write1ByteTxRx(port_num2, PROTOCOL_VERSION, DXL2_ID, ADDR_PRO_TORQUE_ENABLE, TORQUE_ENABLE);\r\n    if ((dxl_comm_result = dynamixel.getLastTxRxResult(port_num2, PROTOCOL_VERSION)) != COMM_SUCCESS)\r\n    {\r\n      System.out.println(dynamixel.getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));\r\n    }\r\n    else if ((dxl_error = dynamixel.getLastRxPacketError(port_num2, PROTOCOL_VERSION)) != 0)\r\n    {\r\n      System.out.println(dynamixel.getRxPacketError(PROTOCOL_VERSION, dxl_error));\r\n    }\r\n    else\r\n    {\r\n      System.out.printf(\"Dynamixel#%d has been successfully connected\\n\", DXL2_ID);\r\n    }\r\n\r\n    while (true)\r\n    {\r\n      System.out.println(\"Press enter to continue! (or press e then enter to quit!)\");\r\n      if(scanner.nextLine().equals(KEY_FOR_ESCAPE))\r\n        break;\r\n\r\n      // Write Dynamixel#1 goal position\r\n      dynamixel.write4ByteTxRx(port_num1, PROTOCOL_VERSION, DXL1_ID, ADDR_PRO_GOAL_POSITION, dxl_goal_position[index]);\r\n      if ((dxl_comm_result = dynamixel.getLastTxRxResult(port_num1, PROTOCOL_VERSION)) != COMM_SUCCESS)\r\n      {\r\n        System.out.println(dynamixel.getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));\r\n      }\r\n      else if ((dxl_error = dynamixel.getLastRxPacketError(port_num1, PROTOCOL_VERSION)) != 0)\r\n      {\r\n        System.out.println(dynamixel.getRxPacketError(PROTOCOL_VERSION, dxl_error));\r\n      }\r\n\r\n      // Write Dynamixel#2 goal position\r\n      dynamixel.write4ByteTxRx(port_num2, PROTOCOL_VERSION, DXL2_ID, ADDR_PRO_GOAL_POSITION, dxl_goal_position[index]);\r\n      if ((dxl_comm_result = dynamixel.getLastTxRxResult(port_num2, PROTOCOL_VERSION)) != COMM_SUCCESS)\r\n      {\r\n        System.out.println(dynamixel.getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));\r\n      }\r\n      else if ((dxl_error = dynamixel.getLastRxPacketError(port_num2, PROTOCOL_VERSION)) != 0)\r\n      {\r\n        System.out.println(dynamixel.getRxPacketError(PROTOCOL_VERSION, dxl_error));\r\n      }\r\n\r\n      do\r\n      {\r\n        // Read Dynamixel#1 present position\r\n        dxl1_present_position = dynamixel.read4ByteTxRx(port_num1, PROTOCOL_VERSION, DXL1_ID, ADDR_PRO_PRESENT_POSITION);\r\n        if ((dxl_comm_result = dynamixel.getLastTxRxResult(port_num1, PROTOCOL_VERSION)) != COMM_SUCCESS)\r\n        {\r\n          System.out.println(dynamixel.getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));\r\n        }\r\n        else if ((dxl_error = dynamixel.getLastRxPacketError(port_num1, PROTOCOL_VERSION)) != 0)\r\n        {\r\n          System.out.println(dynamixel.getRxPacketError(PROTOCOL_VERSION, dxl_error));\r\n        }\r\n\r\n        // Read Dynamixel#2 present position\r\n        dxl2_present_position = dynamixel.read4ByteTxRx(port_num2, PROTOCOL_VERSION, DXL2_ID, ADDR_PRO_PRESENT_POSITION);\r\n        if ((dxl_comm_result = dynamixel.getLastTxRxResult(port_num2, PROTOCOL_VERSION)) != COMM_SUCCESS)\r\n        {\r\n          System.out.println(dynamixel.getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));\r\n        }\r\n        else if ((dxl_error = dynamixel.getLastRxPacketError(port_num2, PROTOCOL_VERSION)) != 0)\r\n        {\r\n          System.out.println(dynamixel.getRxPacketError(PROTOCOL_VERSION, dxl_error));\r\n        }\r\n\r\n        System.out.printf(\"[ID: %d] GoalPos: %d  PresPos: %d [ID: %d] GoalPos: %d  PresPos: %d\\n\", DXL1_ID, dxl_goal_position[index], dxl1_present_position, DXL2_ID, dxl_goal_position[index], dxl2_present_position);\r\n\r\n      } while ((Math.abs(dxl_goal_position[index] - dxl1_present_position) > DXL_MOVING_STATUS_THRESHOLD) || (Math.abs(dxl_goal_position[index] - dxl2_present_position) > DXL_MOVING_STATUS_THRESHOLD));\r\n\r\n      // Change goal position\r\n      if (index == 0)\r\n      {\r\n        index = 1;\r\n      }\r\n      else\r\n      {\r\n        index = 0;\r\n      }\r\n    }\r\n\r\n    // Disable Dynamixel#1 Torque\r\n    dynamixel.write1ByteTxRx(port_num1, PROTOCOL_VERSION, DXL1_ID, ADDR_PRO_TORQUE_ENABLE, TORQUE_DISABLE);\r\n    if ((dxl_comm_result = dynamixel.getLastTxRxResult(port_num1, PROTOCOL_VERSION)) != COMM_SUCCESS)\r\n    {\r\n      System.out.println(dynamixel.getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));\r\n    }\r\n    else if ((dxl_error = dynamixel.getLastRxPacketError(port_num1, PROTOCOL_VERSION)) != 0)\r\n    {\r\n      System.out.println(dynamixel.getRxPacketError(PROTOCOL_VERSION, dxl_error));\r\n    }\r\n\r\n    // Disable Dynamixel#2 Torque\r\n    dynamixel.write1ByteTxRx(port_num2, PROTOCOL_VERSION, DXL2_ID, ADDR_PRO_TORQUE_ENABLE, TORQUE_DISABLE);\r\n    if ((dxl_comm_result = dynamixel.getLastTxRxResult(port_num2, PROTOCOL_VERSION)) != COMM_SUCCESS)\r\n    {\r\n      System.out.println(dynamixel.getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));\r\n    }\r\n    else if ((dxl_error = dynamixel.getLastRxPacketError(port_num2, PROTOCOL_VERSION)) != 0)\r\n    {\r\n      System.out.println(dynamixel.getRxPacketError(PROTOCOL_VERSION, dxl_error));\r\n    }\r\n\r\n    // Close port1\r\n    dynamixel.closePort(port_num1);\r\n\r\n    // Close port2\r\n    dynamixel.closePort(port_num2);\r\n\r\n    return;\r\n  }\r\n}\r\n```\r\nThe first lines of the Console output are:\r\n```bash\r\nSucceeded to open the port(0)!\r\nSucceeded to change the baudrate!\r\nSucceeded to open the port(0)!\r\nSucceeded to change the baudrate!\r\n```\r\n\r\nTo detail **item 2**:\r\nThis one is a bit more obvious: `packetHandler()` should *always* be called after opening all necessary ports. [Internally it allocates a byte[] per port](https://github.com/ROBOTIS-GIT/DynamixelSDK/blob/master/c/src/dynamixel_sdk/packet_handler.c#L43) therefore in a multi port scenario if packet handler is called only after the first port, the byte[] for the second port won't be allocated and therefore cause a `malloc error`:\r\n\r\n```bash\r\njava(97594,0x70000021a000) malloc: *** error for object 0x10f5122d0: pointer being realloc'd was not allocated\r\n*** set a breakpoint in malloc_error_break to debug\r\n```\r\n\r\nCurrently the only workaround I could think off for allowing library users to create servo instances is to use a static port <-> servo lookup table behind the scenes:\r\ne.g. \r\n```java\r\n// this would just populate the static port <-> servo id lookup table\r\nServo servo1 = new Servo(1,\"/dev/tty.usbserial-FT2H2YBE\");\r\nServo servo2 = new Servo(2,\"/dev/tty.usbserial-FT2H2YBE\");\r\nServo servo3 = new Servo(1,\"/dev/tty.usbserial-FT2GZFK0\");\r\nServo servo4 = new Servo(2,\"/dev/tty.usbserial-FT2GZFK0\");\r\n// this would actually call portHandler() / openPort() / setBaudRate() / packetHandler() in the correct order\r\nServo.setupSerial();\r\n```\r\nI'm more than open to suggestions to make this more elegant / obvious to understand.\r\n\r\nThis isn't an issue per se, more of a feature request to add extra notes in the documentation.\r\n\r\nThank you,\r\nGeorge\r\n"
  repo: 'https://api.github.com/repos/ROBOTIS-GIT/DynamixelSDK'
  labels:
    - enhancement
- url: 'https://github.com/ROBOTIS-GIT/DynamixelSDK/issues/223'
  title: >-
    [3.6.2][C]/[Java]/[Python][USB2Dynamixel2][XH430-W350-R] DynamixelSDK still
    holds a reference to the port after it's closed (blocking it until reboot)
  body: "If I run the **readwrite SDK sample** which open the serial port then closes it that works.\r\n\r\nThe issue is I unplug/replug the USB cable **after** I've ran a DynamixelSDK sample once: the serial port disappears (from /dev/tty.*). \r\n\r\nWhat's weird is that the device is still present in System Information USB, even when the USB cable is unplugged. Speaking of cables, I have tried about a dozen microUSB cables (of different lengths, colours and brands) and that didn't have any impact on the issue.\r\n\r\nIt appears the FTDI driver somehow gets in a strange locked state as I can't unload/reload it:\r\n\r\n```bash\r\nsudo kextunload -b com.FTDI.driver.FTDIUSBSerialDriver\r\nPassword:\r\n(kernel) Can't unload kext com.FTDI.driver.FTDIUSBSerialDriver; classes have instances:\r\n(kernel)     Kext com.FTDI.driver.FTDIUSBSerialDriver class FTDIUSBSerialDriver has 1 instance.\r\nFailed to unload com.FTDI.driver.FTDIUSBSerialDriver - (libkern/kext) kext is in use or retained (cannot unload).\r\n```\r\nIf it helps here is some `udev` and `kexstat` info:\r\n```bash\r\n-o USB <-> Serial Converter@14100000  <class AppleUSBDevice, id 0x1000005e2, !registered, !matched, inactive, busy 2 (78721467 ms), retain 13>\r\n      |       +-o USB <-> Serial Converter@0  <class AppleUSBInterface, id 0x1000005f2, !registered, !matched, inactive, busy 2 (78721016 ms), retain 10>\r\n      |         +-o FTDIUSBSerialDriver  <class FTDIUSBSerialDriver, id 0x1000005f4, !registered, !matched, inactive, busy 1 (78720954 ms), retain 6>\r\n      |             {\r\n      |               \"bInterfaceNumber\" = 0\r\n      |               \"CFBundleIdentifier\" = \"com.FTDI.driver.FTDIUSBSerialDriver\"\r\n      |               \"IOProviderClass\" = \"IOUSBInterface\"\r\n      |               \"IOClass\" = \"FTDIUSBSerialDriver\"\r\n      |               \"bConfigurationValue\" = 1\r\n      |               \"IOProbeScore\" = 100000\r\n      |               \"idProduct\" = 24596\r\n      |               \"IOMatchCategory\" = \"IODefaultMatchCategory\"\r\n      |               \"IOPowerManagement\" = {\"CapabilityFlags\"=32768,\"MaxPowerState\"=1,\"CurrentPowerState\"=1}\r\n      |               \"bcdDevice\" = 2304\r\n      |               \"idVendor\" = 1027\r\n      |             }\r\n$ kextstat | grep FTDI\r\n  149    0 0xffffff7f80d6d000 0x7000     0x7000     com.FTDI.driver.FTDIUSBSerialDriver (2.3) ECC3AF36-431D-370D-86F2-5237785E9CF8 <121 39 5 4 3 1>\r\n$ kextstat | grep 121\r\n  121    2 0xffffff7f80d5c000 0xe000     0xe000     com.apple.iokit.IOSerialFamily (11) 854221E2-E1EB-361A-98C6-DC6B7E1EB0F4 <7 6 5 4 3 1>\r\n  122    0 0xffffff7f81b1a000 0xa000     0xa000     com.apple.iokit.IOBluetoothSerialManager (4.4.6f1) 57A03351-E0D2-348B-A442-C4F5B6C4310E <121 7 5 4 3 1>\r\n  149    0 0xffffff7f80d6d000 0x7000     0x7000     com.FTDI.driver.FTDIUSBSerialDriver (2.3) ECC3AF36-431D-370D-86F2-5237785E9CF8 <121 39 5 4 3 1>\r\n```\r\n\r\nI've tested the SDK using:\r\n - the Java library and c library directly\r\n- the C++ library\r\n- the Python version (which uses pyserial)\r\n\r\nThe Java/C/C++ version displayed the same behaviours: once the port handler closed the port, unplugging/replugging the devices rendered it useless until reboot.\r\n\r\nThe Python version couldn't open the port until I manually changed the default baud rate from 1M to 57600.\r\nOnce that worked got the same issue after the port was closed,\r\n\r\nWhat's interesting is that if I simply use pyserial directly to write bytes, not using DynamixelSDK at all, the serial port works as expected.\r\nFor example, if I send LED on, LED off to XH430-350-R with ID 3 as bytes:\r\n```\r\n[0xFF,0xFF,0xFD,0x00,0x03,0x06,0x00,0x03,0x41,0x00,0x01,0xEF,0x64]\r\n[0xFF,0xFF,0xFD,0x00,0x03,0x06,0x00,0x03,0x41,0x00,0x00,0xEA,0xE4]\r\n```\r\n\r\nPython 3 example:\r\n```python\r\n#!/usr/bin/env python3\r\nimport serial\r\nimport time\r\n\r\nID_3_LED_ON  = [0xFF,0xFF,0xFD,0x00,0x03,0x06,0x00,0x03,0x41,0x00,0x01,0xEF,0x64]\r\nID_3_LED_OFF = [0xFF,0xFF,0xFD,0x00,0x03,0x06,0x00,0x03,0x41,0x00,0x00,0xEA,0xE4]\r\n\r\ns = serial.Serial(\"/dev/tty.usbserial-FT2GZFM6\",57600)\r\n\r\ns.write(ID_3_LED_ON)\r\nsleep(3)\r\ns.write(ID_3_LED_OFF)\r\n\r\ns.close()\r\n```\r\nI've tested with Python 2 as well:\r\n```python\r\n#!/usr/bin/env python2\r\nimport serial\r\nimport time\r\n\r\nID_3_LED_ON  = [0xFF,0xFF,0xFD,0x00,0x03,0x06,0x00,0x03,0x41,0x00,0x01,0xEF,0x64]\r\nID_3_LED_OFF = [0xFF,0xFF,0xFD,0x00,0x03,0x06,0x00,0x03,0x41,0x00,0x00,0xEA,0xE4]\r\n\r\ns = serial.Serial(\"/dev/tty.usbserial-FT2GZFM6\",57600)\r\n\r\nfor byte in ID_3_LED_ON:\r\n    s.write(chr(byte))\r\nsleep(3)\r\nfor byte in ID_3_LED_OFF:\r\n    s.write(chr(byte))\r\n\r\ns.close()\r\n```\r\n\r\nI can unplug/replug the U2D2 device and the serial port is still listed and works after running something the above. As soon as I run `DynamixelSDK/python/tests/protocol2_0/read_write.py`, hit ESC, then unplug/replug the U2D2 device it become unusable as a serial port until I reboot OSX.\r\n\r\nAs mentioned before, the same issue can be reproduced with the read/write sample in C / Java (using the same C library) and C++.\r\n\r\nIf the issue could be resolved with the C library that would be amazing (as I guess will also resolve the same issue in Java). Perhaps the extra messages the DynamixelSDK sends via pyserial could be used to identity the issue with the C library ?"
  repo: 'https://api.github.com/repos/ROBOTIS-GIT/DynamixelSDK'
  labels:
    - enhancement
    - question
